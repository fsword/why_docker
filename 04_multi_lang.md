前面其实已经提到，设计和开发人员对基础设施的一个期望是不要限制自己的技术选型，这个需求比较新，因为这是一个趋势的产物——随着我们做的系统越来越复杂，系统间的协作越来越普遍，**单一的技术栈有多元化的趋势**。

#### 说说那些年我们使用过的技术

以我熟悉的B/S结构下的应用系统开发（包括互联网应用）为例，最早的时候可以按照语言划分为三个技术栈：php主打网站开发，微软系主要结合visual studio提供快速应用开发，java其实有些后来居上的味道，借助j2ee对准的是企业应用市场。

后来，旧的EJB模型逐渐式微，spring异军突起，java/j2ee也开始慢慢进入互联网领域，现在以阿里巴巴为首的一些电商就主要采用java相关的技术栈。

从传统的j2ee到hadoop，java社区逐渐变得上下通吃，而php和.net社区也是自成体系。

从2007年开始，Ruby on Rails逐渐被中国开发者社区所接受和追捧，它的卖点是简洁、研发效率高。这时，Ruby优势领域主要是web开发和脚本运维，一些人在进行复杂计算或者面对高并发场景的时候会考虑使用其它语言工具，比如java和erlang......技术栈开始多样化。

到了2011年后，nodejs又异军突起，它主要的卖点是事件驱动模式和异步编程，由于自身机制，nodejs的所有的库都有很好的并发能力，这是ruby社区一直没有彻底解决的，所以一部分ruby开发人员迁移到了nodejs，同时也有一些人开始接触更多的选择，比如scala、closure、lua......技术栈越来越多。

经过这些变迁，至少在互联网领域，常用的技术栈已经不再纯粹，而从2007年开始C10K的逐渐普及，2012年大数据的流行，以及2013年的移动互联网的疯狂，服务端系统的复杂度在直线上升，现在已经很少有公司使用单一语言技术栈来解决问题，即使在淘宝，也会有各种小众语言和技术框架的使用问题。

#### 为什么说多元化是趋势？
也许有人会问，多元技术栈真的是一个趋势吗？上面所说的都只是现象，如果不能解释其内在原因，仅凭片面的观察而做结论是很草率的。
我的回答是——**支持技术栈多元化的企业有生存优势，因此会有越来越多的企业走上这条路**，这就是技术栈多元化的内在原因。

这有点类似生物种群的竞争。
> 【以下受某期罗辑思维启发，在此感谢罗辑思维和《上帝的跳蚤》作者京虎子 :-) 】

我们知道，人类在面对细菌这样的微生物时，体能优势是无法生效的（想想就能理解），种群规模也差得很远（数量级差异），几乎是必败的结局。不过还好我们有两性繁殖这个武器，因此孩子总会与父母有所不同——一种疾病袭来，虽然也有人不幸，然而其他人由于“不同”而得以逃脱厄运，最终，人类在整体上依靠多样性的优势得以繁衍壮大，在医学出现以前就已经踏遍了全球。

这种多样性优势的现象是可以类比在企业中的。当然，企业没有两性繁殖，但是企业有人员流动，在技术不断变化的今天，即使你的企业主要从事的是应用系统软件开发，也可以获取业界的基础技术框架演化的好处——唯一要做的就是不要额外制造障碍。

程序员最喜欢进行各种圣战——编辑器之间的、编程语言之间的、开发框架之间的......常常吵得不亦乐乎，最后一般会有人说这样的话——“其实XXX和YYY都是一样的，讨论谁更牛一点也不重要”。

有时候，说这话的人水平确实很高，技术能力既深且广，所以在他看来这些东西差别不大，但很多时候不是这样。很多人其实是人云亦云，只是自己觉得——“语言背后不都是编译器/虚拟机指令集么？到底层看都一样嘛”，顺便还可以获取一种心理上的深刻感。

这种想法其实有问题，虽然有些争论限于意气不可取，但这些争论本身并非完全无用。

编辑器、编程语言、开发框架......这些都是软件开发的工具，而工具反映了其作者对某个问题领域的认识，工具作者实际上是要使用某种统一的解决方案，“批量的”解决某一类问题。因此这些工具背后是对问题领域知识的建模，是作者的方法论和思考方式。

不同作者的思维习惯和用力点不同，其制造的工具也会因此而有利有弊。

我在知乎上回答过一个[问题](http://zhi.hu/lk8m)  ，讨论ruby的优势，但其它语言也有自身的优势。比如，并行编程领域的nodejs或者erlang，一开始就是在事件驱动模型或者轻量级进程下工作，三方库基本都不会导致阻塞，使用起来自然得心应手，ruby就没有这个条件。java常被用来吐槽，但如果我要写个守护进程同时工作在windows、linux上，我还是会选择java，因为它从一开始就立足于“一次编译，到处运行”（有一种说法，sun当年为了避免过多的本地特性，特地将jni设计的很难使用），因此三方库一般也是pure java的，不必担心迁移的问题。

再例如，充血模型是2004~2005年期间被广泛接受的设计理念，然而在面对海量数据的web应用中，如果将一次请求的结果构造为充血的对象，其成本很高。因此，选择充血模型的ORM库也就有其适用和不适用的场景。

甚至编辑器也是如此，不同编辑器代表不同的思维方式，因此不建议用一种工具写所有的代码。比如我自己，写java用Intelij IDEA，写Ruby/RoR用vim，原因很简单，java代码中的一些“废话”是可以通过IDE理解并建立抽象语法树进行关联的，而动态的ruby不太容易做到那么完善的分析（后者提高生产率的标准做法是建立DSL简化代码）。

工具当然只是工具，但如果我们勤于思考，**客观的判断将有助于我们在合适的场合选择最恰当的工具，改进研发工作**。

基于这个思考回过头再看看技术栈多样性。由于不同的语言框架有其适用范围，而IT/互联网企业面对的又是一个急剧变化的市场，我们常常需要进行产品调整，此时，支持技术栈多样性的企业将可以更加游刃有余的选择合适的技术栈。

试想一下，如果一个互联网公司刚开始创业，它很可能采用RoR，而且多半前后端一勺烩，省时省力，接下来呢？搜索、消息引擎、数据分析这些业务会逐渐加入，应用本身也会分布化，这时用ruby就未必是最好的选择，我们可能要考虑引入hadoop，所以至少要有人能管理java应用；另外一个可能的方向是接口数据化，即随着前后端业务分离，服务端主要的工作将变为提供数据接口，原来基于ActiveRecord的模型需要瘦身，模型本身也需要拆解为不同的应用，前端可能需要nodejs来支撑，页面部分也许会使用类似reactor这样的框架，于是就要用一个纯js框架。要让企业继续快速前进，技术栈多元化将是不可避免的。

这并不是想当然，实际中也存在这样的情况，我之前工作在阿里巴巴，主要的业务应用都是遵循历史惯例使用java，公司的基础设施也只能支持java应用，结果，当RoR潮流来临时，团队没有其它选择，虽然我在团队做过几次分享，也确实有同事希望用合适的技术提升开发效率，然而由于运维团队的基础设施没有考虑这个可能，所以团队不得不专门抽出人手尝试将RoR的一些好的做法“移植到”java世界中——熟悉这些技术的人知道这是多大的浪费，结果也不难预料，这些工作无疾而终。

> 无独有偶，nodejs也有类似的尴尬，据说某团队一开始引入nodejs的时候也遇到了类似的情况，他们的对策是——被迫放弃公司在运维、项目管理基础设施上提供的各种服务，将这些工作针对nodejs又重新做了一遍。

也许有人觉得这些例子有些特殊，毕竟一个团队也不一定有多少机会变更编程语言（上述情况是因为公司规模增大以后，不同的团队需要针对自己的实际情况选择不同的技术栈）。但事情并没那么简单，如果一开始在建立基础设施的时候没有考虑多样性这个趋势，那么很容易就走向了用控制代替管理。即使同样是java应用，也会有版本不同，于是就出现了这样的现象——开发团队不能选择生产力更高的新版本jdk，即使从技术上看已经成熟可靠。

在这种情况下，缺少了技术栈多样性的情况下，软件开发这件事变成了“锤子的故事”——手里只有一把锤子，自然要把所有的问题都变成钉子才行，面对竞争对手的瑞士军刀，一线工程师的难受可想而知，最后不可避免要用加班来弥补生产力的不足，企业的竞争力也自然会大打折扣。阿里巴巴在电子商务领域提倡建立一个生态系统，但是其研发活动却没有考虑建立多样性的生态系统，限制了活力，不得不说是比较遗憾的。

#### 现实的困难与Docker的回答
一方面，原有的、绑定在单一语言技术框架下的基础设施面对研发人员越来越多的挑战。另一方面，在技术栈逐渐多样化变迁的同时，软件和互联网企业开始逐渐接受了敏捷的理念。
>当前，越来越多的公司都在追求敏捷，一线的工程师们也在不遗余力的推进社区的各种最佳实践，其中就有持续集成和持续交付。而持续集成和持续交付的一个很重要的基础设施就是配置管理，这包括源码如何管理、打包/单元测试/集成测试如何进行、交付产物如何标准化、部署怎样自动化等等问题。

这两个方面的变化交织在一起，使得问题更加复杂，想要企业的研发基础设施既能支持多元化的技术栈，又能统一软件交付流程，是一个很大的挑战，这要求公共的服务设施寻找一个最普遍的基础。

实际上，我们面临的是共性和个性这对矛盾，过于强调共性则会丢失个性，过于强调个性则会失去平台的统一。还好，在服务器软件领域，我们有linux这样一个相对好的公共基础，唯一的问题是linux本身也有众多的distribution，各种工具不尽相同。这时Docker横空出世，我们发现，经过Docker“简化”的linux能很好的处理这个问题。

与早期的PAAS比如GAE相比，docker让用户使用的是一个真正的linux环境，而且，docker本身并不排斥各种distribution，在共性和个性的矛盾中，docker把权力交给了用户，让用户来自己准备自己的技术基础设施。

这个思路很类似chef/puppet，自己掌握的环境自然具有最大的弹性和灵活性，方便用户发挥技术上的创新能力。不过docker更进一步，它提供了image/container机制，借助AUFS/overlayfs这样的技术，用户可以很简单的将某些基础设施固化，比如以小团队或者以语言/框架技术栈为单位建立基础镜像，然后各团队叠加自己的业务代码，这样做节约了时间，也就意味着可能将这种环境管理能力从线上扩展到线下，这是相对于chef/puppet更加先进的地方。

这个变化对整个研发领域是有影响的：

1. 借助这个能力，我们可以用合适的技术解决恰当的问题，而不再需要“*手里拿着锤子，看什么都像钉子*”。当然，过去我们也期望这么做，但是由于基础设施的缺位，我们要控制自己的技术构想，让步于架构的可行，现在约束少了很多，架构师将更有自由度。

2. docker的方案是“将环境交给开发者”，因此，开发人员需要懂linux，虽然不用当孔乙己，但是熟悉环境将不再是少数人的责任。
> 粗看起来这是开发人员的坏消息，其实不然，我们之前提到过，docker实际上是对linux的某种简化，这使得开发人员的学习成本降低了不少，以我的标准看，学习docker时需要了解的东西，基本上也就是一名开发人员本就应该学会的东西了。

当然，上述说法并非人人同意，现实中确实也有这样的情况——业务场景的重要性非常重要，以至于我们不能在技术学习上占用太多的时间，开发人员需要先抓紧时间学习核心知识。这时，比较好的做法是借助docker hub查找你使用的技术栈的环境，然后找到最为流行的镜像，用之即可——这背后更象是分工的体现。

最后但并非不重要的一点，是关于多元技术栈的协作方式。通过现实中的系统实践，我认识到**应该尽量避免混合语言编程**，不同的语言技术栈应当保持其独立性，然后进行进程间、系统间协作，用搭积木的方式来搭建系统，这是改进系统可维护性的重要一点。这意味着我们要尽可能的分拆原有的大而全的系统设计，而这种协作也需要有基础设施的支持。所幸Docker不是一个单一技术，它背后还有compose、swarm、mesos等框架组织配合，帮助我们进行管理。

基于docker这样的技术，我们就可以用通用的方式为不同技术栈提供配管、运维等基础设施，这条路指向的正是云，这也是现在 Container as a service 变得越来越热的原因。

#### 总结
从一元到多元，技术栈的发明还将日新月异，但是我们很容易就可以将它装入docker这个盒子中，借助服务发现和容器编制，我们可以让异构的技术彼此合作，发挥各自的优势。这正如人类发明了越来越多的商品和原材料，但还是统一使用集装箱，这样就可以用很低的成本互通有无，实现全球合作。
